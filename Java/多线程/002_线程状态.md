# 线程状态

java[线程状态](https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.State.html)包括：

+ NEW - 线程创建之后，但是还没有启动

+ RUNNABLE - `RUNNABLE` 状态的线程在 JVM 虚拟机正在 Java 虚拟机中执行，但它可能正在等待来自于操作系统的其它资源，比如处理器。实际上，如果一个线程在等待阻塞I/O的操作时，它的状态也是 `RUNNABLE` 的

+ BLOCKED 

  > A thread that is blocked waiting for a monitor lock is in this state.

  > 阻塞状态，等待锁的释放，比如线程A进入了一个synchronized方法，线程B也想进入这个方法，但是这个方法的锁已经被线程A获取了，这个时候线程B就处于BLOCKED状态

+ WAITING

  > A thread that is waiting indefinitely(不确定性的) for another thread to perform a particular action is in this state.

  等待状态，处于等待状态的线程是由于执行了3个方法中的任意方法

  + Object.wait with no timeout
  + [Thread.join](http://www.geeksforgeeks.org/joining-threads-in-java/) with no timeout
  + LockSupport.park

  再举个例子，如果一个线程调用了一个对象的wait方法，那么这个线程就会处于waiting状态直到另外一个线程调用这个对象的notify或者notifyAll方法后才会解除这个状态

+ TIMED_WAITING 

  > A thread that is waiting for another thread to perform an action for up to a specified waiting time is in this state.

  有等待时间的等待状态，比如调用了以下几个方法中的任意方法，并且指定了等待时间，线程就会处于这个状态

  + Thread.sleep
  + Object.wait with timeout
  + Thread.join with timeout
  + LockSupport.parkNanos
  + LockSupport.parkUntil

+ TERMINATED - 线程中止的状态

![001.jpg](https://github.com/winfredzen/JavaEE-Basic/blob/master/Java/多线程/images/001.jpg)

参考：

+ [Java线程状态分析](https://fangjian0423.github.io/2016/06/04/java-thread-state/)
+ [Lifecycle and States of a Thread in Java](https://www.geeksforgeeks.org/lifecycle-and-states-of-a-thread-in-java/)